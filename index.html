<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta name="referrer" content="no-referrer">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self'; script-src 'self' https://cdnjs.cloudflare.com https://html2canvas.hertzen.com https://cdn.jsdelivr.net https://gc.zgo.at https://static.cloudflareinsights.com 'unsafe-inline'; style-src 'self' https://cdnjs.cloudflare.com 'unsafe-inline'; font-src 'self' https://cdnjs.cloudflare.com; img-src 'self' data: https://gc.zgo.at https://cdn.jsdelivr.net; connect-src 'self' https://linsnotes.goatcounter.com https://docs.google.com https://*.googleusercontent.com; object-src 'none'; base-uri 'self';">
    <title>Language Marksman</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous">
    <!-- Removed SortableJS CSS -->

    <style>
        :root {
            /* --- Original Variables (Keep for consistency elsewhere) --- */
            --primary: #1a73e8; /* Modern blue color */
            --primary-hover: #0b5fdb; /* Darker shade for hover */
            --secondary: #e5e7eb;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --warning: #f59e0b; /* Yellow */
            --light: #f9fafb;
            --accent: #8b5cf6; /* target color */
            --target-text-color: white; /* target text color */
            --dark: #111827; /* shooter color (original) */
            --shooter-text-color: white; /* shooter text color */
            --success: #10b981; /* Green */
            --danger: #ef4444; /* Red */
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --radius: 0.5rem;
            --transition: all 0.3s ease;
            --word-box-font-family: KaiTi, 'Kaiti SC', DFKai-SB, BiauKai, 'Microsoft YaHei', 'SimHei', 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --word-box-font-size: 1.6rem; /* Slightly larger for game elements */
            --shooter-speed: 15px;
            --bullet-speed: 15px;
            --target-downward-speed: 0.5px;
            --target-horizontal-speed-max: 1.5px;
    
            /* --- NEW Variables for Modern Quiz Screen Theme --- */
            --quiz-bg-start: #2d3748; /* Dark Slate Blue */
            --quiz-bg-end: #1a202c; /* Darker Slate Blue */
            --quiz-text-light: #e2e8f0; /* Light Gray for text on dark bg */
            --quiz-text-dim: #a0aec0; /* Dimmer Gray */
            --quiz-header-bg: rgba(26, 32, 44, 0.6); /* Semi-transparent dark bg for header */
            --quiz-header-item-bg: rgba(74, 85, 104, 0.5); /* Slightly lighter bg for items */
            --quiz-progress-bg: rgba(255, 255, 255, 0.15); /* Subtle progress bar background */
            --quiz-progress-bar: #4fd1c5; /* Teal/Cyan progress bar */
            --quiz-game-area-bg: #1a202c; /* Match dark bg end */
            --quiz-shooter-bg: linear-gradient(to bottom, #4a5568, #2d3748); /* Grey gradient */
            --quiz-shooter-accent: var(--primary); /* Use primary blue for accent */
            --quiz-target-bg: var(--accent); /* Keep existing purple */
            --quiz-target-shadow: rgba(0, 0, 0, 0.5);
            --quiz-bullet-color: #f6e05e; /* Bright Yellow */
            --quiz-bullet-glow: rgba(246, 224, 94, 0.7);
            --quiz-mobile-button-bg: rgba(45, 55, 72, 0.7); /* Dark, semi-transparent */
            --quiz-mobile-button-active-bg: rgba(26, 32, 44, 0.9);
            --quiz-mobile-button-icon: #cbd5e0; /* Light icon color */
        }
    
        /* --- General Styles (Mostly Unchanged) --- */
        .rotate-icon { display: inline-block; animation: spin 3s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .fill-text { display: inline-block; background: linear-gradient(90deg, var(--primary), var(--accent)); background-size: 200% 100%; -webkit-background-clip: text; color: transparent; animation: fillText 5s ease infinite; }
        @keyframes fillText { from { background-position: -100% 0; } to { background-position: 0 0; } }
    
        body { font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif; margin: 0; padding: 0; background-color: #f3f4f6; color: var(--text-primary); line-height: 1.5; }
        h1, h2, h3, h4, h5, h6 { font-weight: 600; margin-top: 0; color: var(--dark); }
        h1 { font-size: 2rem; margin-bottom: 1.5rem; }
        h2 { font-size: 1.5rem; margin-bottom: 1rem; }
    
        .app-container { max-width: 1140px; margin: 0 auto; padding: 1rem; min-height: 100vh; display: flex; flex-direction: column; box-sizing: border-box; } /* Added box-sizing */
        .app-header { text-align: center; padding: 1rem 0; border-bottom: 1px solid var(--secondary); margin-bottom: 2rem; }
        .app-footer { margin-top: auto; text-align: center; padding: 1rem 0; font-size: 0.875rem; color: var(--text-secondary); border-top: 1px solid var(--secondary); }
        .app-footer a { color: #6b7280; text-decoration: none; }
    
        .screen { display: none; opacity: 0; transition: opacity 0.5s ease, transform 0.5s ease; transform: translateY(10px); }
        .screen.active { display: block; opacity: 1; transform: translateY(0); }
        /* Ensure quizScreen uses flex when active */
        #quizScreen.active { display: flex; flex-direction: column; }
    
        .card { background: white; border-radius: var(--radius); box-shadow: var(--shadow); padding: 2rem; margin-bottom: 1.5rem; transition: var(--transition); }
        .card-header { margin-bottom: 1.5rem; border-bottom: 1px solid var(--secondary); padding-bottom: 1rem; }
        .card-title { font-size: 1.25rem; margin: 0; }
        .card-body { margin-bottom: 1.5rem; }
        .card-footer { border-top: 1px solid var(--secondary); padding-top: 1rem; display: flex; justify-content: center; flex-wrap: wrap; gap: 0.5rem; }
    
        .form-group { margin-bottom: 1.5rem; }
        .form-control { display: block; width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid var(--secondary); border-radius: var(--radius); transition: var(--transition); box-sizing: border-box; }
        .form-control:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2); }
        #quizId, #userName { width: 100%; margin: 0; padding: 0.75rem; }
        .center-button { text-align: center; }
    
        .btn { display: inline-block; font-weight: 500; text-align: center; vertical-align: middle; user-select: none; padding: 0.75rem 1.5rem; font-size: 1rem; line-height: 1.5; border-radius: var(--radius); transition: var(--transition); cursor: pointer; border: none; }
        .btn-primary { background-color: var(--primary); color: white; }
        .btn-primary:hover { background-color: var(--primary-hover); }
        .btn-secondary { background-color: var(--secondary); color: var(--text-primary); }
        .btn-secondary:hover { background-color: #d1d5db; }
    
        /* ======================================== */
        /* === START: Modern Quiz Screen Styles === */
        /* ======================================== */
    
        #quizScreen {
            position: relative;
            overflow: hidden;
            flex-grow: 1; /* Allow quiz screen to expand */
            /* NEW Background: Darker Gradient */
            background: linear-gradient(180deg, var(--quiz-bg-start) 0%, var(--quiz-bg-end) 100%);
            display: flex; /* Already set, ensures flex context */
            flex-direction: column; /* Stack header/progress/gameArea vertically */
            color: var(--quiz-text-light); /* Default text color for quiz screen */
        }
    
        .quiz-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            gap: 0.75rem; /* Spacing between items */
            padding: 0.75rem 1rem; /* Adjust padding */
            /* NEW Background: Subtle dark, slightly transparent */
            background: var(--quiz-header-bg);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* Subtle separator */
            position: relative; /* Keep stacking context */
            z-index: 20;
            border-radius: var(--radius) var(--radius) 0 0; /* Round top corners if desired */
        }
    
        /* Style for items within the header */
        .timer-container,
        .quiz-title-display,
        .question-counter,
        #bulletCounter,
        .pause-btn { /* Apply to bullet counter too */
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: 600;
            color: var(--quiz-text-light); /* Use light text */
            padding: 0.5rem 1rem;
            /* NEW Background: Distinct item background */
            background: var(--quiz-header-item-bg);
            border-radius: var(--radius);
            font-size: 0.9rem; /* Slightly smaller */
            flex-grow: 0; /* Don't allow them to grow excessively */
            flex-shrink: 1; /* Allow shrinking */
            border: none; /* Ensure button border is reset */
            cursor: pointer; /* Add pointer */
        }
    
        .timer-container i {
            color: var(--quiz-progress-bar); /* Use progress bar color for icon */
        }
        .timer-value {
            color: white; /* Make timer value stand out */
            font-weight: 700;
        }
        #bulletCounter i {
            color: var(--quiz-bullet-color); /* Use bullet color */
        }
         /* Ensure bulletCounter is styled correctly when shown */
        #bulletCounter {
            display: flex; /* Keep this if JS sets it, otherwise use default above */
            /* Other styles inherited from the common rule above */
        }

        /* Specific styles for the pause button if needed */
        .pause-btn {
            padding: 0.6rem 0.8rem; /* Adjust padding for better icon centering */
            justify-content: center; /* Center icon */
        }
        .pause-btn:hover {
             background-color: rgba(99, 112, 133, 0.7); /* Slightly lighter on hover */
        }
        .pause-btn i {
            margin: 0; /* Remove potential margins from icon */
            font-size: 1rem; /* Adjust icon size if needed */
        }

        /* **** START: Add Pause Overlay Styles **** */
        #pauseOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7); /* Dark semi-transparent background */
            color: white;
            font-size: 3rem;
            font-weight: bold;
            display: flex; /* Use flexbox for centering */
            justify-content: center;
            align-items: center;
            z-index: 150; /* Make sure it's above everything else in gameArea */
            border-radius: 0 0 var(--radius) var(--radius); /* Match gameArea bottom radius */
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            /* display: none; is set inline initially via HTML */
        }
        /* **** END: Add Pause Overlay Styles **** */

    
        /* Instructions */
        .quiz-instructions {
            margin: 0; /* Remove default margins */
            padding: 0.5rem 1rem; /* Reduced padding */
            /* NEW: Match header background */
            background-color: var(--quiz-header-bg);
            border-left: none; /* Remove side border */
            border-radius: 0;
            font-size: 0.8rem; /* Smaller text */
            color: var(--quiz-text-dim); /* Dimmer text color */
            text-align: center; /* Center align */
            position: relative;
            z-index: 20;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1); /* Match header border */
        }
    
        /* Progress Bar */
        .progress-container {
            width: 100%;
            height: 6px; /* Thinner */
            /* NEW Background */
            background-color: var(--quiz-progress-bg);
            border-radius: 3px;
            overflow: hidden;
            margin: 0; /* Remove margin */
            position: relative;
            z-index: 20; /* Below header but above game area content */
        }
    
        .progress-bar {
            height: 100%;
            /* NEW Bar color */
            background-color: var(--quiz-progress-bar);
            transition: width 0.3s ease;
            border-radius: 3px; /* Match container */
        }
    
        /* Game Area */
        #gameArea {
            position: relative;
            flex-grow: 1; /* Fill remaining space */
            /* NEW Background */
            background-color: var(--quiz-game-area-bg);
            /* Optional: Subtle inner shadow for depth */
            box-shadow: inset 0 4px 15px rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Keep content contained */
            border-radius: 0 0 var(--radius) var(--radius); /* Round bottom corners */
        }
    
        /* --- Target Styling (Mostly unchanged shape, refined look) --- */
        .target {
            position: absolute;
            padding: 0.8rem;
            width: auto;
            min-width: 3rem;
            aspect-ratio: 1 / 1;
            display: flex;
            justify-content: center;
            align-items: center;
            /* NEW: Use variable */
            background-color: var(--quiz-target-bg);
            color: var(--target-text-color); /* Keep white text */
            border-radius: 50%; /* Keep circular */
            font-family: var(--word-box-font-family);
            font-size: calc(var(--word-box-font-size) * 0.75); /* Adjust size if needed */
            transition: transform 0.2s ease, background-color 0.2s ease;
            /* NEW: Subtle border and stronger shadow for dark theme */
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 5px 10px var(--quiz-target-shadow), inset 0 1px 2px rgba(255, 255, 255, 0.2);
            z-index: 5;
            user-select: none;
            white-space: nowrap;
            text-align: center;
        }
    
        /* --- Target Hit Animations (Unchanged Functionality) --- */
        @keyframes targetHitCorrect {
            0% { transform: scale(1) rotate(0deg); opacity: 1; background-color: var(--success); box-shadow: 0 0 15px var(--success); } /* Added glow */
            50% { transform: scale(1.3) rotate(15deg); opacity: 0.5; }
            100% { transform: scale(0.5) rotate(-15deg); opacity: 0; background-color: var(--success); }
        }
        .target-hit-correct {
            animation: targetHitCorrect 0.5s ease-out forwards;
            pointer-events: none;
        }
    
        @keyframes targetHitIncorrect {
            0% { transform: translateX(0); opacity: 1; background-color: var(--danger); box-shadow: 0 0 15px var(--danger); } /* Added glow */
            20% { transform: translateX(-8px); }
            40% { transform: translateX(8px); }
            60% { transform: translateX(-8px); }
            80% { transform: translateX(8px); }
            100% { transform: translateX(0); opacity: 0; background-color: var(--danger); }
        }
        .target-hit-incorrect {
            animation: targetHitIncorrect 0.5s linear forwards;
            pointer-events: none;
        }

        /* --- Modern TOP-DOWN TANK Shooter Style --- */
        /* --- Modern TOP-DOWN TANK Shooter Style --- */
        #shooter {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            /* Hull Dimensions */
            width: auto;       /* ADD auto width */
            min-width: 70px;   /* ADD minimum width (adjust as needed) */
            padding-left: 15px;  /* ADD horizontal padding */
            padding-right: 15px; /* ADD horizontal padding */

            
            height: 45px; /* Slightly taller hull */
            /* Hull Styling */
            background: linear-gradient(to bottom, #4a5568, #2d3748); /* Grey gradient hull */
            border: 1px solid rgba(0, 0, 0, 0.4);
            border-radius: 5px; /* Slightly rounded hull corners */
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.1); /* Depth and slight highlight */
            /* Text Styling (inside the hull) */
            white-space: nowrap;
            text-align: center;
            line-height: 45px; /* Match hull height */
            color: var(--shooter-text-color);
            font-size: calc(var(--word-box-font-size) * 0.7); /* Adjusted font size */
            font-weight: 600;
            z-index: 10; /* Ensure hull is behind turret/barrel but above bg */
            /* Remove padding if any was added previously */
            padding: 0;
            /* Remove old top border */
            border-top: none;
        }

        /* Turret Style */
        #shooter::after {
            content: ''; /* Required for pseudo-elements */
            position: absolute;
            /* Turret Dimensions & Shape */
            width: 35px;  /* Turret width */
            height: 20px; /* Turret height */
            
            /* Original line: */
            /* border-radius: 50%; */ /* Circular turret */
        
            /* --- MODIFIED LINE --- */
            border-radius: 100% 100% 0 0; /* Semi-circle (Rounded Top, Flat Bottom) */
            /* --- END MODIFICATION --- */
        
            /* Turret Positioning (Centered on top part of hull) */
            left: 50%;
            top: -20px; /* Position vertically relative to hull top (adjust as needed) */
                               /* This positioning should still work fine */
            transform: translateX(-50%);
            /* Turret Styling */
            background: linear-gradient(to bottom, #6b7280, #4a5568); /* Slightly lighter grey gradient */
            border: 1px solid rgba(0, 0, 0, 0.5);
            /* Optional: Adjust border to only apply to top/sides if desired */
            /* border-bottom: none; */ /* <--- Add this if you want no bottom border line */
            box-shadow: inset 0 1px 1px rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0,0,0,0.3);
            z-index: 12; /* Ensure turret is above hull */
        }

    
        /* Barrel Style */
        #shooter::before {
            content: ''; /* Required for pseudo-elements */
            position: absolute;
            /* Barrel Dimensions & Shape */
            width: 6px;   /* Narrow barrel */
            height: 25px; /* Barrel length */
            border-radius: 3px 3px 0 0; /* Slightly rounded top */
            /* Barrel Positioning (Extending from turret center) */
            left: 50%;
            top: -40px; /* Position vertically above turret ( -18px turret top + ~-22px barrel height/offset ) */
            transform: translateX(-50%);
            /* Barrel Styling */
            background: #2d3748; /* Darker gunmetal color */
            border: 1px solid rgba(0, 0, 0, 0.6);
            box-shadow: inset 0 -1px 1px rgba(0,0,0,0.3);
            z-index: 11; /* Ensure barrel is above hull, can be below turret center visually */
        }
    
        /* --- Modern Bullet Style --- */
        .bullet-visual {
            position: absolute;
            width: 8px; /* Slightly thicker */
            height: 18px; /* Slightly taller */
            /* NEW Background: Bright Yellow */
            background-color: var(--quiz-bullet-color);
            border-radius: 4px 4px 0 0; /* Rounded top */
            /* NEW Glow Effect */
            box-shadow: 0 0 10px 3px var(--quiz-bullet-glow);
            z-index: 9; /* Above shooter, below hit targets? */
            pointer-events: none;
            display: none; /* Keep hidden for the template */
        }
    
        /* --- Mobile Controls --- */
        #mobile-controls {
            position: absolute;
            bottom: 5px;
            left: 10px;
            right: 10px;
            height: 60px; /* Keep height */
            z-index: 100; /* Keep on top */
            pointer-events: none;
            display: none; /* Keep default hidden */
        }
    
        #quizScreen.active #mobile-controls {
            display: block;
        }
    
        #mobile-controls button {
            position: absolute;
            bottom: 0;
            width: 55px;
            height: 55px;
            /* NEW Background: Darker, semi-transparent */
            background-color: var(--quiz-mobile-button-bg);
            border: 1px solid rgba(255, 255, 255, 0.2); /* Subtle border */
            border-radius: 50%;
            /* NEW Icon color */
            color: var(--quiz-mobile-button-icon);
            font-size: 1.4rem;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            transition: background-color 0.1s ease, transform 0.1s ease; /* Added transform transition */
            box-shadow: 0 2px 5px rgba(0,0,0,0.4); /* Add shadow */
        }
    
        #mobile-controls button:active {
            /* NEW Active state */
            background-color: var(--quiz-mobile-button-active-bg);
            transform: scale(0.95); /* Add slight shrink effect */
        }
    
        /* Positioning remains the same */
        #mobile-fire { left: 0; }
        #mobile-right { right: 0; }
        #mobile-left { right: 65px; }
    
        /* Hide keyboard instructions on touch devices (existing rule) */
        @media (hover: none) and (pointer: coarse) {
            .quiz-instructions {
                display: none;
            }
            /* Optional: Increase shooter size slightly on touch devices for easier visibility */
            /* #shooter { width: 90px; height: 45px; line-height: 45px; } */
        }
        /* ====================================== */
        /* === END: Modern Quiz Screen Styles === */
        /* ====================================== */
    
    
        /* --- Results Screen Styles (Unchanged) --- */
        .result-summary { padding: 1.5rem; background-color: #f3f4f6; border-radius: var(--radius); margin-bottom: 1.5rem; }
        .result-stat { display: flex; align-items: center; margin-bottom: 0.75rem; }
        .result-stat i { margin-right: 0.75rem; color: var(--primary); width: 24px; text-align: center; }
        .results-table-container { overflow-x: auto; margin-bottom: 1.5rem; }
        .results-table { width: 100%; border-collapse: collapse; font-size: 0.875rem; }
        .results-table th, .results-table td { padding: 0.75rem; text-align: left; border-bottom: 1px solid var(--secondary); }
        .results-table th { background-color: #f9fafb; font-weight: 600; color: var(--text-secondary); }
        .results-table tr:hover td { background-color: #f3f4f6; }
        .results-table td.correct { color: var(--success); font-weight: bold; }
        .results-table td.incorrect { color: var(--danger); font-style: italic; }
        .results-table td.failed { color: var(--danger); font-style: italic; }
    
        /* --- Other Unchanged Styles --- */
        .divider { display: flex; align-items: center; margin: 1.5rem 0; color: var(--text-secondary); font-size: 0.875rem; }
        .divider::before, .divider::after { content: ""; flex: 1; border-bottom: 1px solid var(--secondary); }
        .divider::before { margin-right: 1rem; }
        .divider::after { margin-left: 1rem; }
    
        #quizSelect { width: 100%; padding: 0.75rem; font-size: 1rem; border: 1px solid var(--secondary); border-radius: var(--radius); transition: var(--transition); background-color: white; color: var(--text-primary); appearance: none; -webkit-appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%236b7280'%3E%3Cpath d='M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0.75rem top 50%; background-size: 1.25rem; }
        #quizSelect:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px rgba(26, 115, 232, 0.2); }
    
        /* --- Responsive Adjustments --- */
        @media (max-width: 768px) {
            /* Non-Quiz Screen Adjustments (Unchanged) */
            .card { padding: 1.5rem; }
            .results-table th, .results-table td { padding: 0.5rem; font-size: 0.75rem; }
    
            /* Quiz Screen Specific Adjustments */
            .quiz-header {
                justify-content: space-around; /* Better distribution when wrapping */
                gap: 0.5rem; /* Smaller gap */
                padding: 0.5rem; /* Less padding */
            }
            .timer-container,
            .quiz-title-display,
            .question-counter,
            #bulletCounter,
            .pause-btn {
                padding: 0.4rem 0.6rem; /* Smaller padding */
                font-size: 0.8rem; /* Smaller font */
                /* Allow flexible sizing */
                flex-basis: auto; /* Let flexbox decide basis */
                flex-grow: 1; /* Allow growing */
                min-width: auto; /* Allow smaller button */
                text-align: center;
                justify-content: center;
            }

            .pause-btn i { font-size: 0.9rem; 
            } /* Adjust icon size */
            
            #pauseOverlay { font-size: 2rem; 
            } /* Smaller overlay text */

             /* Reduce target size */
            .target {
                min-width: 2.5rem;
                font-size: calc(var(--word-box-font-size) * 0.65);
                padding: 0.6rem; /* Adjust padding */
                border-width: 1px; /* Thinner border */
                box-shadow: 0 3px 6px var(--quiz-target-shadow), inset 0 1px 1px rgba(255, 255, 255, 0.2); /* Adjust shadow */
            }
            /* Adjust shooter size */
            #shooter {
                 width: 70px;
                 height: 35px;
                 line-height: 35px;
                 font-size: calc(var(--word-box-font-size) * 0.7);
                 bottom: 5px;
                 border-top-width: 3px;
            }
            /* Adjust mobile button size/position if needed */
             #mobile-controls button { width: 50px; height: 50px; font-size: 1.2rem; }
             #mobile-left { right: 60px; } /* Adjust gap */
        }
    
        @media (max-width: 480px) {
            /* Non-Quiz Screen Adjustments (Unchanged) */
            h1 { font-size: 1.8rem; }
            .card-footer { justify-content: center; }
            .btn { width: 100%; margin-bottom: 0.5rem; }
    
            /* Quiz Screen Specific Adjustments */
            .quiz-header { padding: 0.5rem; gap: 0.3rem; }
            .timer-container,
            .quiz-title-display,
            .question-counter,
            #bulletCounter,
            .pause-btn {
                font-size: 0.75rem; /* Even smaller font */
                padding: 0.3rem 0.5rem;
                min-width: 100px; /* Adjust min-width */
                gap: 0.3rem;
            }

            .pause-btn i { font-size: 0.8rem;
            } /* Adjust icon size */
            
            #pauseOverlay { font-size: 1.8rem;
            } /* Smaller overlay text */


            
            .quiz-title-display { font-size: 0.8rem; /* Keep title slightly larger */ }
    
            /* Further reduce target size */
            .target {
                min-width: 2.2rem;
                font-size: calc(var(--word-box-font-size) * 0.6);
                padding: 0.5rem;
            }
            /* Further adjust shooter size */
            #shooter {
                width: 60px;
                height: 30px;
                line-height: 30px;
                font-size: calc(var(--word-box-font-size) * 0.65);
                bottom: 2px;
                border-top-width: 2px;
            }
             /* Adjust mobile button size/position */
             #mobile-controls { height: 55px; } /* Reduce container height slightly */
             #mobile-controls button { width: 45px; height: 45px; font-size: 1.1rem; }
             #mobile-left { right: 55px; } /* Adjust gap */
        }
    
    </style>
    
</head>
<body>
    <div class="app-container">
        <header class="app-header">
             <h1><i class="fas fa-location-crosshairs rotate-icon"></i>
                <span class="fill-text">Language Marksman</span>
             </h1>
        </header>

        <!-- Landing Screen -->
        <div id="landingScreen" class="screen active">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Welcome to Language Marksman</h2>
                    <p><span style="margin-right: 0.4rem;">🚀</span>See it. Shoot it. Master it.</p>
                </div>
                <div class="card-body">
                    <!-- Quiz Selection -->
                    <div class="form-group">
                        <label for="quizSelect" class="form-label">Built-in Games:</label>
                        <select id="quizSelect" class="form-control"></select> <!-- Options populated by JS -->
                    </div>
                    <div class="center-button">
                        <button onclick="startSelectedQuiz()" class="btn btn-primary" disable> <!-- Initially disabled -->
                            <i class="fas fa-play-circle"></i> Start Built-in Game
                        </button>
                    </div>
                    <div class="divider">OR</div>

                    <div class="form-group">
                        <label for="quizId" class="form-label">Have a custom game?</label>
                        <p class="form-text" style="margin-top: 0.25rem; margin-bottom: 0.5rem; color: var(--text-secondary); font-size: 0.875rem;">
                            <i class="fas fa-info-circle"></i> Game ID is provided by your teacher
                        </p>
                        <input type="text" id="quizId" placeholder="Enter Game ID" class="form-control" autocomplete="off">
                    </div>
                </div>
                 <div class="center-button">
                    <button onclick="startCustomQuiz()" class="btn btn-secondary">
                        <i class="fas fa-file-import"></i> Start Custom Game
                    </button>
                </div>
            </div>
        </div>

        <!-- Name Screen -->
        <div id="nameScreen" class="screen">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Ready Player?</h2>
                </div>
                <div class="card-body">
                    <div class="form-group">
                        <label for="userName" class="form-label">Enter Your Name</label>
                        <input type="text" id="userName" required class="form-control" placeholder="Your Name" autocomplete="name">
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="startQuiz()" class="btn btn-primary">
                        <i class="fas fa-gamepad"></i> Start Game
                    </button>
                    <button onclick="goHome()" class="btn btn-secondary">
                        <i class="fas fa-home"></i> Back to Home
                    </button>
                </div>
            </div>
        </div>

        <!-- Quiz Screen -->
        <div id="quizScreen" class="screen">
             <!-- Header elements (now above game area) -->
            <div class="quiz-header">
                <div class="timer-container">
                    <i class="fas fa-clock"></i> Time: <span id="timer" class="timer-value">0</span>s
                </div>
                 <div id="quizTitleDisplay" class="quiz-title-display">
                     <!-- Quiz title will be shown here -->
                 </div>
                
                <div class="question-counter" id="questionNumber"></div>
                <div id="bulletCounter" class="bullet-counter" style="display: none; align-items: center; gap: 0.5rem; font-weight: 600; color: var(--text-secondary); padding: 0.5rem 1rem; background: var(--light); border-radius: var(--radius); margin-left: 1rem;"> {/* Added margin-left for spacing */}
                    <!-- Content set by JS -->
                </div>

                <!-- **** START: Add Pause/Resume Button **** -->
                <button id="pauseResumeButton" class="quiz-header-item pause-btn" title="Pause Game">
                    <i class="fas fa-pause"></i>
                </button>
                <!-- **** END: Add Pause/Resume Button **** -->

        
            </div>
            <div id="progressContainer" class="progress-container">
                <div id="progressBar" class="progress-bar" style="width: 0%"></div>
            </div>
             <div class="quiz-instructions">
                <i class="fas fa-arrows-alt-h"></i> Move: Left/Right Arrows    <i class="fas fa-keyboard"></i> Fire: Spacebar
            </div>

            <!-- Game Area -->
            <div id="gameArea">
                 <!-- Shooter -->
                <div id="shooter">
                    <!-- Current Column A word here -->
                </div>

                 <!-- **** START: Add Pause Overlay **** -->
                 <div id="pauseOverlay" style="display: none;">PAUSED</div>
                 <!-- **** END: Add Pause Overlay **** -->


                <!-- Bullet Element (initially hidden) -->
                <div id="bullet" class="bullet-visual"></div>
            </div>
                <!-- Targets will be added here by JS -->
                <!-- START: Add Mobile Controls HTML -->
            <div id="mobile-controls">
                <button id="mobile-fire" aria-label="Fire"><i class="fas fa-crosshairs"></i></button>
                <button id="mobile-left" aria-label="Move Left"><i class="fas fa-arrow-left"></i></button>
                <button id="mobile-right" aria-label="Move Right"><i class="fas fa-arrow-right"></i></button>
            </div>
                <!-- END: Add Mobile Controls HTML -->
        </div>

        <!-- Results Screen -->
        <div id="resultsScreen" class="screen">
            <div class="card">
                <div class="card-header">
                    <h2 class="card-title">Game Results</h2>
                </div>
                <div class="card-body">
                    <div class="result-summary" id="resultSummary">
                        <!-- Results summary will be inserted here -->
                    </div>

                    <div class="results-table-container">
                        <table id="resultsTable" class="results-table">
                            <!-- Results table will be inserted here -->
                        </table>
                    </div>
                </div>
                <div class="card-footer">
                    <button onclick="screenshotResults()" class="btn btn-secondary">
                        <i class="fas fa-camera"></i> Screenshot Results
                    </button>
                    <button onclick="reviewQuestions()" class="btn btn-primary">
                        <i class="fas fa-redo"></i> Play Again
                    </button>
                     <button onclick="goHome()" class="btn btn-secondary">
                        <i class="fas fa-home"></i> Back to Home
                    </button>
                </div>
            </div>
        </div>

        <footer class="app-footer">
            <div id="visitor-counter">
               Welcome! You're visitor #<span id="pageviews">Loading...</span>
            </div>
            <p><a href="https://linsnotes.com">linsnotes.com</a></p>
        </footer>
    </div>

    <!-- Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.17.4/xlsx.full.min.js" integrity="sha512-gtII6Z4fZyONX9GBrF28JMpodY4vIOI0lBjAtN/mcK7Pz19Mu1HHIRvXH6bmdChteGpEccxZxI0qxXl9anY60w==" crossorigin="anonymous"></script>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11" integrity="sha512-gFZWRLz/L0wM7xbDPBvkaLw2M3WQsgyRbBq42895frJ6F+Byb6KheFCad5wSlP+y3uUwtntBMYo9Q0qZapwoww==" crossorigin="anonymous"></script>
    <script data-goatcounter="https://linsnotes.goatcounter.com/count" async src="https://gc.zgo.at/count.v4.js" integrity="sha512-s8rneFEWl5dZg0RnrW/4sYlxNwe2OiEjWP6HByBiynyEKKuQNynYoBhI1XeleM5UiHhYxoeYdhCjyBRAV7mdoQ==" crossorigin="anonymous"></script>


    <script>
        // --- Global State ---
        let currentQuestion = 0;
        let quizData = []; // Array of { colA: "word1", colB: "match1" }
        let allColBTargets = []; // Array of all unique Column B words for target generation
        let userData = { name: '', startTime: 0, attempts: [], totalPoints: 0 };
        let timerInterval;
        // let timerPaused = false; // REMOVED - Replaced by isPaused
        let elapsedTime = 0;
        let questionStartTime = 0;
        let questionAttempts = {};
        let questionRetryCount = {};
        let questionFailed = false;
        let currentSheetId = ''; // Store the ID of the currently selected/entered quiz
        let currentCorrectAnswer = ''; // Store the correct answer for the current question

        // **** START: Add Pause State Variable ****
        let isPaused = false;
        let pauseStartTime = 0; // Time when the current pause began
        let totalPauseDurationForQuestion = 0; // Total time paused during the current questi
        // **** END: Add Pause State Variable ****

        // --- Constants & Config ---
        const QUIZ_LIST_SHEET_ID = '1b_yzMM-qy_g9Sa-kO5mPtAL67neZdaIW_QIQcfFHaNg'; // Replace if needed
        const SHOOTER_MOVE_SPEED = 15;
        let unlimitedBulletsEnabled = false;
        let bulletLimit = 2;
        const BULLET_SPEED = 12;
        const TARGET_DOWNWARD_SPEED = 0.5;
        const TARGET_HORIZONTAL_SPEED_MAX = 1.0;
        const TARGET_SPAWN_Y_OFFSET = -50;
        const TARGET_FAILURE_PADDING = 20;
        let numberOfOptions = 4;

        // --- NEW CONSTANTS FOR POPUP TIMERS ---
        const POPUP_TIMER_CORRECT_MS = 1200;
        const POPUP_TIMER_INCORRECT_MS = 1200;

        // --- Game State ---
        let gameLoopId = null;
        let shooterX = 0;
        let activeBullets = [];
        let activeTargets = [];
        let keysPressed = {};
        let gameActive = false;
        let quizTitlesAndIds = []; // Store fetched built-in quiz titles/IDs

        let detachedQuizScreen = null;

        // --- DOM Cache ---
        const DOMElements = {
            landingScreen: document.getElementById('landingScreen'),
            nameScreen: document.getElementById('nameScreen'),
            quizScreen: document.getElementById('quizScreen'),
            resultsScreen: document.getElementById('resultsScreen'),
            quizSelect: document.getElementById('quizSelect'),
            quizIdInput: document.getElementById('quizId'),
            userNameInput: document.getElementById('userName'),
            timerDisplay: document.getElementById('timer'),
            quizTitleDisplay: document.getElementById('quizTitleDisplay'),
            questionNumberDisplay: document.getElementById('questionNumber'),
            progressBar: document.getElementById('progressBar'),
            gameArea: document.getElementById('gameArea'),
            shooter: document.getElementById('shooter'),
            bulletTemplate: document.getElementById('bullet'),
            bulletCounter: document.getElementById('bulletCounter'),
            resultSummary: document.getElementById('resultSummary'),
            resultsTable: document.getElementById('resultsTable'),
            startBuiltInButton: document.querySelector('button[onclick="startSelectedQuiz()"]'),
            appHeader: document.querySelector('.app-header'),
            appFooter: document.querySelector('.app-footer'),
            mobileControls: document.getElementById('mobile-controls'),
            mobileLeft: document.getElementById('mobile-left'),
            mobileRight: document.getElementById('mobile-right'),
            mobileFire: document.getElementById('mobile-fire'),
            // **** START: Add New Elements to Cache ****
            pauseResumeButton: document.getElementById('pauseResumeButton'),
            pauseOverlay: document.getElementById('pauseOverlay')
            // **** END: Add New Elements to Cache ****
        };

        // --- Computed Styles Cache ---
        const primaryColor = getComputedStyle(document.documentElement).getPropertyValue('--primary').trim();
        const textSecondary = getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim();

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            loadQuizTitlesAndIds();
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('keyup', handleKeyUp);
            setupMobileControls();

            // **** START: Add Pause Button Event Listener ****
            if (DOMElements.pauseResumeButton) {
                DOMElements.pauseResumeButton.addEventListener('click', togglePause);
            } else {
                console.error("Pause/Resume button not found!");
            }
            // **** END: Add Pause Button Event Listener ****

            setupVisitorCounter(); // Renamed the direct fetch logic for clarity
        });

        // Encapsulate visitor counter logic
        function setupVisitorCounter() {
            const pv = document.getElementById('pageviews');
            if (pv !== null) {
                const uri = location.pathname.replace(/\/$/, '');
                const url = `https://linsnotes.goatcounter.com/counter/${encodeURIComponent(uri)}.json`;
                fetch(url)
                    .then((response) => response.json())
                    .then((data) => {
                        if (data && data.count) {
                            const count = data.count.replace(/\s/g, '');
                            pv.innerText = new Intl.NumberFormat().format(count);
                        } else {
                             pv.innerText = 'N/A';
                        }
                    })
                    .catch((error) => {
                        console.warn("Failed to fetch visitor count:", error);
                        pv.innerText = 'N/A'; // Indicate failure
                    });
            }
        }

        // --- Screen Management ---
        function showScreen(screenId) {
            document.querySelectorAll('.screen').forEach(s => {
                s.classList.remove('active');
                s.style.display = ''; // Clear inline display
            });
            const targetScreen = DOMElements[screenId];
            if (targetScreen) {
                targetScreen.classList.add('active');
                // Set display based on screen type
                targetScreen.style.display = (screenId === 'quizScreen') ? 'flex' : 'block';
            } else {
                console.error(`Screen with ID ${screenId} not found.`);
                DOMElements.landingScreen.classList.add('active'); // Fallback
                DOMElements.landingScreen.style.display = 'block';
            }

            // Control header/footer visibility
            const showHeaderFooter = (screenId !== 'quizScreen');
            DOMElements.appHeader.style.display = showHeaderFooter ? 'block' : 'none';
            DOMElements.appFooter.style.display = showHeaderFooter ? 'block' : 'none';

            // Control game loop activity and pause button visibility/state
            gameActive = (screenId === 'quizScreen');
            if (DOMElements.pauseResumeButton) {
                DOMElements.pauseResumeButton.style.display = gameActive ? 'flex' : 'none'; // Show/hide button
                if (!gameActive && isPaused) { // If leaving quiz screen while paused, ensure it gets unpaused state-wise
                    isPaused = false; // Reset flag directly
                    // Icon/Overlay handled by subsequent showScreen call or resetQuizState
                } else if (gameActive && isPaused) {
                     // If returning to quiz screen and it *should* be paused, ensure overlay is shown
                     if (DOMElements.pauseOverlay) DOMElements.pauseOverlay.style.display = 'flex';
                }
            }
            // Ensure overlay is hidden if not paused when showing quiz screen
            if (gameActive && !isPaused && DOMElements.pauseOverlay) {
                 DOMElements.pauseOverlay.style.display = 'none';
            }
        }

        function goHome() {
            stopGameLoop(); // Stops game loop and clears keysPressed
            clearInterval(timerInterval); // Clear timer interval explicitly
            resetQuizState(true); // Full reset including name, quiz data etc.

            // Reset UI elements specifically for going home
            DOMElements.quizIdInput.value = '';
            DOMElements.quizSelect.selectedIndex = 0; // Reset dropdown
            if (DOMElements.startBuiltInButton) DOMElements.startBuiltInButton.disabled = true; // Disable built-in start
            DOMElements.userNameInput.value = ''; // Clear name input

            // Ensure header/footer are shown for landing screen
            DOMElements.appHeader.style.display = 'block';
            DOMElements.appFooter.style.display = 'block';

            showScreen('landingScreen'); // Navigate to landing screen
        }

        // --- Mobile Controls Setup ---
        function setupMobileControls() {
            const leftBtn = DOMElements.mobileLeft;
            const rightBtn = DOMElements.mobileRight;
            const fireBtn = DOMElements.mobileFire;

            if (!leftBtn || !rightBtn || !fireBtn) {
                if (DOMElements.mobileControls) DOMElements.mobileControls.style.display = 'none';
                console.warn("Mobile control buttons not found.");
                return;
            }

            const handleMoveStart = (e, direction) => {
                // **** ADD PAUSE CHECK ****
                if (isPaused || !gameActive) return;
                e.preventDefault();
                const arrowKey = direction === 'left' ? 'ArrowLeft' : 'ArrowRight';
                const oppositeKey = direction === 'left' ? 'ArrowRight' : 'ArrowLeft';
                keysPressed[arrowKey] = true;
                keysPressed[oppositeKey] = false; // Prevent simultaneous opposite movement
                e.target.closest('button')?.classList.add('active-control');
            };

            const handleMoveEnd = (e, direction) => {
                // No pause check needed here, just clear flags if they exist
                const arrowKey = direction === 'left' ? 'ArrowLeft' : 'ArrowRight';
                keysPressed[arrowKey] = false;
                document.querySelectorAll('#mobile-controls .active-control').forEach(el => el.classList.remove('active-control'));
            };

            const handleFire = (e) => {
                 // **** ADD PAUSE CHECK ****
                if (isPaused || !gameActive) return;
                e.preventDefault();
                fireBullet();
                const btn = e.target.closest('button');
                if (btn) {
                    btn.classList.add('active-control');
                    // Use mouseup/touchend to remove class for better hold-fire feel if needed later
                    setTimeout(() => btn.classList.remove('active-control'), 100); // Simple visual feedback
                }
            };

            // Touch Events
            leftBtn.addEventListener('touchstart', (e) => handleMoveStart(e, 'left'), { passive: false });
            leftBtn.addEventListener('touchend', (e) => handleMoveEnd(e, 'left'));
            leftBtn.addEventListener('touchcancel', (e) => handleMoveEnd(e, 'left'));
            rightBtn.addEventListener('touchstart', (e) => handleMoveStart(e, 'right'), { passive: false });
            rightBtn.addEventListener('touchend', (e) => handleMoveEnd(e, 'right'));
            rightBtn.addEventListener('touchcancel', (e) => handleMoveEnd(e, 'right'));
            fireBtn.addEventListener('touchstart', handleFire, { passive: false });

            // Mouse Events (for testing/hybrid) - Ensure correct key flags are set
            leftBtn.addEventListener('mousedown', (e) => handleMoveStart(e, 'left'));
            leftBtn.addEventListener('mouseup', (e) => handleMoveEnd(e, 'left'));
            leftBtn.addEventListener('mouseleave', (e) => handleMoveEnd(e, 'left')); // Stop if mouse leaves while pressed
            rightBtn.addEventListener('mousedown', (e) => handleMoveStart(e, 'right'));
            rightBtn.addEventListener('mouseup', (e) => handleMoveEnd(e, 'right'));
            rightBtn.addEventListener('mouseleave', (e) => handleMoveEnd(e, 'right')); // Stop if mouse leaves while pressed
            fireBtn.addEventListener('mousedown', handleFire);
            // Optional: remove active class on mouseup/leave for fire button if needed
             fireBtn.addEventListener('mouseup', (e) => e.target.closest('button')?.classList.remove('active-control'));
             fireBtn.addEventListener('mouseleave', (e) => e.target.closest('button')?.classList.remove('active-control'));
        }

        // --- Data Loading ---
        async function loadSheetData(sheetId) {
            try {
                const url = `https://docs.google.com/spreadsheets/d/${sheetId}/export?format=csv&gid=0`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csv = await response.text();
                const workbook = XLSX.read(csv, { type: 'string' });
                const sheetName = workbook.SheetNames[0];
                if (!sheetName) throw new Error('No sheet found.');

                const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });

                window.quizTitle = rows?.[0]?.[0]?.trim() || `Quiz (${sheetId.substring(0, 6)}...)`;

                // Read C1 for Number of Target Options
                const optionsCellValue = rows?.[0]?.[2];
                let parsedOptions = parseInt(optionsCellValue, 10);
                numberOfOptions = (!isNaN(parsedOptions) && parsedOptions >= 1) ? parsedOptions : 4;
                if (numberOfOptions < 1) numberOfOptions = 1; // Failsafe
                console.log(`INFO: Number of target options: ${numberOfOptions}`);

                // Read D1 for Bullet Control
                const bulletControlValue = rows?.[0]?.[3];
                const trimmedD1Value = (bulletControlValue != null) ? String(bulletControlValue).trim() : '';
                const positiveIntegerRegex = /^[1-9]\d*$/;

                console.log(`DEBUG: Read D1 value (trimmed): '${trimmedD1Value}'`);

                if (trimmedD1Value === '') {
                    unlimitedBulletsEnabled = false;
                    bulletLimit = 2;
                    console.log("INFO: D1 empty. Limited (2 bullets default).");
                } else if (positiveIntegerRegex.test(trimmedD1Value)) {
                    unlimitedBulletsEnabled = false;
                    bulletLimit = parseInt(trimmedD1Value, 10);
                    console.log(`INFO: D1 is positive integer. Limited (${bulletLimit} bullets).`);
                } else {
                    unlimitedBulletsEnabled = true;
                    bulletLimit = Infinity; // Represents unlimited
                    console.log(`INFO: D1 is text/other. Unlimited bullets.`);
                }

                const data = rows.slice(1)
                    .map(row => ({
                        colA: row[0] ? String(row[0]).trim() : null,
                        colB: row[1] ? String(row[1]).trim() : null
                    }))
                    .filter(item => item.colA && item.colB);

                if (data.length === 0) {
                     console.warn('WARN: Sheet has no valid data rows.');
                     // Propagate the error indication
                     throw new Error('No valid questions found in the sheet.');
                }
                allColBTargets = [...new Set(data.map(item => item.colB))];
                return data;

            } catch (error) {
                console.error('ERROR: Error loading sheet data:', error);
                 // Use the error message from the catch block for more specific feedback
                Swal.fire('Error Loading Game', `Could not load game data for ID [${sheetId}]. ${error.message}`, 'error', { confirmButtonColor: primaryColor });
                return null; // Return null to indicate failure
            }
        }

        async function loadQuizTitlesAndIds() {
            if (!QUIZ_LIST_SHEET_ID || QUIZ_LIST_SHEET_ID === 'YOUR_QUIZ_LIST_SHEET_ID_HERE') {
                console.warn("Quiz List Sheet ID not set.");
                DOMElements.quizSelect.innerHTML = '<option value="" disabled selected>Built-in Games Unavailable</option>';
                DOMElements.quizSelect.disabled = true;
                DOMElements.startBuiltInButton.disabled = true;
                return;
            }
            try {
                const url = `https://docs.google.com/spreadsheets/d/${QUIZ_LIST_SHEET_ID}/export?format=csv&gid=0`;
                const response = await fetch(url);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const csv = await response.text();
                const workbook = XLSX.read(csv, { type: 'string' });
                const sheetName = workbook.SheetNames[0];
                if (!sheetName) throw new Error('No sheet found for quiz list.');
                const rows = XLSX.utils.sheet_to_json(workbook.Sheets[sheetName], { header: 1 });

                quizTitlesAndIds = rows.slice(1)
                    .map(row => ({ title: row[0]?.trim(), id: row[1]?.trim() }))
                    .filter(quiz => quiz.title && quiz.id);
                populateQuizSelect();
            } catch (error) {
                console.error('Error loading game titles:', error);
                Swal.fire('Error Loading Game List', `Could not load built-in Games. Details: ${error.message}`, 'error', { confirmButtonColor: primaryColor });
                DOMElements.quizSelect.innerHTML = '<option value="" disabled selected>Error Loading Games</option>';
                DOMElements.quizSelect.disabled = true;
                DOMElements.startBuiltInButton.disabled = true;
            }
        }

        function populateQuizSelect() {
            const select = DOMElements.quizSelect;
            select.innerHTML = ''; // Clear previous options
            if (!quizTitlesAndIds || quizTitlesAndIds.length === 0) {
                select.innerHTML = '<option value="" disabled selected>No Built-in Games Found</option>';
                select.disabled = true;
                DOMElements.startBuiltInButton.disabled = true;
                return;
            }
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = "-- Select a Built-in Game --";
            defaultOption.disabled = true;
            defaultOption.selected = true;
            select.appendChild(defaultOption);

            quizTitlesAndIds.forEach(quiz => {
                const option = document.createElement('option');
                option.value = quiz.id;
                option.textContent = quiz.title;
                select.appendChild(option);
            });

            select.disabled = false;
            DOMElements.startBuiltInButton.disabled = true; // Start disabled until selection

            select.addEventListener('change', function() {
                currentSheetId = this.value; // Store selected ID
                DOMElements.quizIdInput.value = ''; // Clear custom input
                DOMElements.startBuiltInButton.disabled = !this.value; // Enable button if value selected
            });
        }

        // --- Quiz Flow Control ---
        function startSelectedQuiz() {
            const selectedId = DOMElements.quizSelect.value;
            if (!selectedId) {
                Swal.fire('No Game Selected', 'Please select a game from the dropdown list.', 'warning', { confirmButtonColor: primaryColor });
                return;
            }
            currentSheetId = selectedId; // Update global ID
            startQuizFlow(currentSheetId);
        }

        async function startCustomQuiz() {
            const sheetId = DOMElements.quizIdInput.value.trim();
            if (!sheetId) {
                Swal.fire('Missing Input', 'Please enter a Custom Quiz Google Sheet ID.', 'warning', { confirmButtonColor: primaryColor });
                return;
            }
            currentSheetId = sheetId; // Update global ID
            startQuizFlow(currentSheetId);
        }

        async function startQuizFlow(sheetId) {
            // Re-attach quizScreen if it was detached from a previous game end
            if (detachedQuizScreen && !document.contains(detachedQuizScreen)) {
                 // Ensure the main container exists before appending
                 const appContainer = document.querySelector('.app-container');
                 if (appContainer) {
                     appContainer.appendChild(detachedQuizScreen);
                     // Re-cache potentially lost elements if needed, though full cache is usually fine
                     // DOMElements.quizScreen = document.getElementById('quizScreen'); // Example
                     console.log("Re-attached quiz screen.");
                 } else {
                     console.error("App container not found, cannot re-attach quiz screen.");
                     goHome(); // Fallback if container is missing
                     return;
                 }
                 detachedQuizScreen = null; // Clear the reference
            }


            Swal.fire({ title: 'Loading Game', text: 'Please wait...', allowOutsideClick: false, showConfirmButton: false, willOpen: () => Swal.showLoading() });
            const data = await loadSheetData(sheetId);
             Swal.close(); // Close loading indicator regardless of success/failure

            if (!data) { // loadSheetData now returns null on error or empty data
                // Error message is shown inside loadSheetData
                goHome(); // Go back home on load failure
                return;
            }

            quizData = data;
            resetQuizState(false); // Reset state but keep potentially entered name/currentSheetId
            // currentSheetId is already set by the caller (startSelectedQuiz/startCustomQuiz)

             // Proceed to name screen
             showScreen('nameScreen');
             // Pre-fill name if it exists from a previous non-full reset
             DOMElements.userNameInput.value = userData.name || '';
        }

        /**
         * Resets the quiz state, clearing game variables, timers, UI elements,
         * and optionally resetting player name and quiz data.
         */
        function resetQuizState(fullReset = true) {
            // --- Stop Core Game Processes ---
            stopGameLoop(); // Clears gameLoopId, gameActive, keysPressed
            clearInterval(timerInterval); // Stop the overall timer

            // --- Reset Game State Variables ---
            currentQuestion = 0;
            timerInterval = null;
            elapsedTime = 0;
            questionStartTime = 0;
            questionAttempts = {};
            questionRetryCount = {};
            questionFailed = false;
            currentCorrectAnswer = '';

            // **** START: Reset Pause State ****
            isPaused = false;
            if (DOMElements.pauseOverlay) DOMElements.pauseOverlay.style.display = 'none';
            if (DOMElements.pauseResumeButton) {
                 const icon = DOMElements.pauseResumeButton.querySelector('i');
                 if (icon) {
                    icon.classList.remove('fa-play');
                    icon.classList.add('fa-pause');
                 }
                 DOMElements.pauseResumeButton.title = 'Pause Game';
                 // Button visibility is handled by showScreen
            }
            // **** END: Reset Pause State ****

            // --- Clear Active Game Elements (Arrays and DOM) ---
            activeTargets.forEach(t => t.element?.remove()); // Use optional chaining for safety
            activeTargets = [];
            activeBullets.forEach(b => b.element?.remove());
            activeBullets = [];

            // --- Reset User Data ---
             // Keep name if not a full reset, otherwise clear it
            userData.startTime = 0;
            userData.attempts = [];
            userData.totalPoints = 0;

            if (fullReset) {
                userData.name = ''; // Clear name only on full reset
                quizData = [];
                allColBTargets = [];
                currentSheetId = ''; // Clear current sheet ID
                window.quizTitle = '';
                // Reset game settings read from sheet to defaults
                numberOfOptions = 4;
                unlimitedBulletsEnabled = false;
                bulletLimit = 2;
            }

            // --- Clear/Reset UI Elements (Quiz Screen Specific) ---
            // Check if elements exist before modifying
            DOMElements.resultSummary?.remove();
            DOMElements.resultsTable?.remove();

            // Clear game area children carefully
             if (DOMElements.gameArea) {
                Array.from(DOMElements.gameArea.children).forEach(child => {
                    // Keep shooter, bullet template, mobile controls, and pause overlay
                    if (child !== DOMElements.shooter &&
                        child !== DOMElements.bulletTemplate &&
                        child !== DOMElements.mobileControls &&
                        child !== DOMElements.pauseOverlay) {
                        child.remove();
                    }
                });
             }

             // Reset specific quiz UI parts if they exist
             if (DOMElements.shooter) DOMElements.shooter.textContent = '';
             if (DOMElements.progressBar) DOMElements.progressBar.style.width = '0%';
             if (DOMElements.timerDisplay) DOMElements.timerDisplay.textContent = '0';
             if (DOMElements.questionNumberDisplay) DOMElements.questionNumberDisplay.textContent = '';
             if (DOMElements.quizTitleDisplay) DOMElements.quizTitleDisplay.textContent = '';
             if (DOMElements.bulletCounter) DOMElements.bulletCounter.style.display = 'none'; // Hide counter
             if (DOMElements.bulletTemplate) DOMElements.bulletTemplate.style.display = 'none'; // Ensure template hidden


            // Reset shooter position (done later in loadQuestion/startQuiz, but safe to do here too)
            requestAnimationFrame(() => {
                 positionShooter();
            });

            console.log("Quiz state reset complete. Full reset:", fullReset);
        }

        function startQuiz() {
            userData.name = DOMElements.userNameInput.value.trim();
            if (!userData.name) {
                Swal.fire('Missing Input', 'Please enter your name.', 'warning', { confirmButtonColor: primaryColor });
                return;
            }
            // Initialize attempt/retry counts for all questions
            quizData.forEach((_, idx) => {
                questionAttempts[idx] = 0;
                questionRetryCount[idx] = 0;
            });

            // Reset pause state explicitly before starting
            isPaused = false;
             if (DOMElements.pauseOverlay) DOMElements.pauseOverlay.style.display = 'none';
             if (DOMElements.pauseResumeButton) {
                 const icon = DOMElements.pauseResumeButton.querySelector('i');
                 if (icon) {
                    icon.classList.remove('fa-play');
                    icon.classList.add('fa-pause');
                 }
                 DOMElements.pauseResumeButton.title = 'Pause Game';
                 DOMElements.pauseResumeButton.style.display = 'flex'; // Ensure button is visible
             }

            showScreen('quizScreen'); // This sets gameActive = true and handles button visibility
            DOMElements.quizTitleDisplay.textContent = window.quizTitle || 'Language Shooter';
            positionShooter(); // Set initial shooter position (centered)
            loadQuestion(); // Loads the first question and starts the game loop
            startTimer(); // Starts the overall quiz timer
        }

        // --- Game Logic ---
        function positionShooter() {
             // Ensure elements exist before calculating
             if (!DOMElements.gameArea || !DOMElements.shooter) return;
            const gameAreaWidth = DOMElements.gameArea.clientWidth;
            const shooterWidth = DOMElements.shooter.offsetWidth;
            // Set the internal state variable for position
            shooterX = (gameAreaWidth - shooterWidth) / 2;
            // Apply the style - Use translateX for potentially smoother rendering
            // DOMElements.shooter.style.left = `${shooterX}px`; // Old method
             DOMElements.shooter.style.left = '50%'; // Center using %
             DOMElements.shooter.style.transform = `translateX(-50%)`; // Adjust with transform
             // Note: If using transform, updateShooterPosition needs to modify transform directly
             // Let's stick to style.left for now to minimize changes from original
             DOMElements.shooter.style.left = `${shooterX}px`;
             DOMElements.shooter.style.transform = `translateX(0)`; // Reset transform if using left
        }


        function clearGameElements() {
            // Remove target DOM elements safely
            activeTargets.forEach(t => t.element?.remove());
            activeTargets = []; // Clear the tracking array

            // Remove active bullet DOM elements safely
            activeBullets.forEach(b => b.element?.remove());
            activeBullets = []; // Clear the tracking array

            // Ensure bullet template is hidden (CSS usually handles this, but good backup)
            if (DOMElements.bulletTemplate) {
                 DOMElements.bulletTemplate.style.display = 'none';
            }
        }

        function spawnTargets() {
            const gameArea = DOMElements.gameArea;
             if (!gameArea) return; // Exit if game area not found
            const areaWidth = gameArea.clientWidth;
            const areaHeight = gameArea.clientHeight;

            // Clear previous targets (should be done by clearGameElements, but safe)
            // activeTargets.forEach(t => t.element?.remove()); // Redundant?
            // activeTargets = [];

            const correctAnswer = currentCorrectAnswer;
            let incorrectOptions = allColBTargets.filter(target => target !== correctAnswer);
            incorrectOptions = shuffle(incorrectOptions);

            // Calculate needed incorrect, ensuring at least 0
             const numberOfIncorrectNeeded = Math.max(0, numberOfOptions - 1);
             // Ensure we don't request more incorrect options than available
             const actualIncorrectCount = Math.min(numberOfIncorrectNeeded, incorrectOptions.length);

            const selectedIncorrect = incorrectOptions.slice(0, actualIncorrectCount);

            // Build the list of targets to show
            let finalTargetsToShow = [];
             // Only add correct answer if it exists in the pool and options > 0
             if (numberOfOptions > 0 && allColBTargets.includes(correctAnswer)) {
                finalTargetsToShow.push(correctAnswer);
             } else if (!allColBTargets.includes(correctAnswer)) {
                 console.warn("Correct answer for question", currentQuestion + 1, "not found in allColBTargets list.");
             }

             // Add the selected incorrect options
             finalTargetsToShow.push(...selectedIncorrect);

            // Shuffle the final list if there's more than one target
            if (finalTargetsToShow.length > 1) {
                 finalTargetsToShow = shuffle(finalTargetsToShow);
            }

             // Ensure the total doesn't exceed numberOfOptions (edge case)
             finalTargetsToShow = finalTargetsToShow.slice(0, numberOfOptions);


            console.log(`Spawning ${finalTargetsToShow.length} targets (requested ${numberOfOptions}):`, finalTargetsToShow);

            // Create target elements
            finalTargetsToShow.forEach((targetWord, index) => {
                const targetElement = document.createElement('div');
                targetElement.className = 'target';
                targetElement.textContent = targetWord;
                targetElement.dataset.word = targetWord;

                gameArea.appendChild(targetElement); // Add to DOM to measure

                const targetWidth = targetElement.offsetWidth;
                const targetHeight = targetElement.offsetHeight;

                 // Improved initial positioning to prevent overlap
                 let x;
                 let attempts = 0;
                 const maxAttempts = 20; // Increase attempts for better spacing
                 let placed = false;
                 let spacingFactor = 1.2; // Minimum spacing = 1.2 * target width

                 do {
                    // Try placing across the width, avoiding edges slightly
                    x = (areaWidth - targetWidth * 1.2) * Math.random() + (targetWidth * 0.1);
                    placed = true;
                    // Check against already placed targets *in this spawn cycle*
                    for (let i = 0; i < activeTargets.length; i++) {
                        const existingTarget = activeTargets[i];
                        // Check for horizontal overlap (increase buffer)
                        if (Math.abs(x - existingTarget.x) < (targetWidth + existingTarget.width) * 0.5 * spacingFactor) {
                             placed = false;
                             break;
                        }
                    }
                    attempts++;
                 } while (!placed && attempts < maxAttempts);

                 // If still not placed, fall back to random (less ideal)
                 if (!placed) {
                     x = Math.random() * (areaWidth - targetWidth);
                     console.warn("Could not guarantee non-overlapping placement, using random X for target:", targetWord);
                 }


                 // Slightly varied initial Y position above screen
                 const y = TARGET_SPAWN_Y_OFFSET - (Math.random() * areaHeight * 0.2) - (targetHeight * index * 0.05);

                // Initial Velocity
                const vx = (Math.random() * 2 - 1) * TARGET_HORIZONTAL_SPEED_MAX; // -Max to +Max
                const vy = TARGET_DOWNWARD_SPEED;

                targetElement.style.left = `${x}px`;
                targetElement.style.top = `${y}px`;

                activeTargets.push({
                    element: targetElement,
                    x: x, y: y,
                    vx: vx, vy: vy,
                    word: targetWord,
                    width: targetWidth,
                    height: targetHeight,
                    hit: false
                });
            });
        }


        // --- Input Handling ---
        function handleKeyDown(event) {
            // **** MODIFY: Add pause check ****
            if (isPaused || !gameActive) return; // Ignore input if paused or game not active

            // Allow pause key (e.g., 'P') even if paused, to resume
             if (event.code === 'KeyP') { // Example: Use 'P' to toggle pause
                togglePause();
                return; // Don't process further for pause key
             }

            keysPressed[event.code] = true;

            // Handle firing immediately on Space press down
            if (event.code === 'Space') {
                // Check pause again specifically before firing
                if (isPaused) return;
                fireBullet();
                event.preventDefault(); // Prevent scrolling page down
            }

             // Optional: Add KeyA/KeyD mapping if desired (add to updateShooterPosition too)
             if (event.code === 'KeyA') keysPressed['ArrowLeft'] = true;
             if (event.code === 'KeyD') keysPressed['ArrowRight'] = true;
        }

        function handleKeyUp(event) {
            // No pause check needed here, just clear the flag if game is active
             if (!gameActive) return;

            keysPressed[event.code] = false;

             // Optional: Clear mapped keys
             if (event.code === 'KeyA') keysPressed['ArrowLeft'] = false;
             if (event.code === 'KeyD') keysPressed['ArrowRight'] = false;
        }

        function updateShooterPosition() {
             if (!DOMElements.gameArea || !DOMElements.shooter) return; // Safety check

            const gameAreaWidth = DOMElements.gameArea.clientWidth;
            const shooterWidth = DOMElements.shooter.offsetWidth;
            const moveAmount = SHOOTER_MOVE_SPEED;

             // Use consistent keys (ArrowLeft/Right, potentially mapped from A/D in keydown)
            if (keysPressed['ArrowLeft']) {
                 shooterX -= moveAmount;
            }
            if (keysPressed['ArrowRight']) {
                 shooterX += moveAmount;
            }

            // Clamp position to stay within game area bounds
             // Clamp based on the element's left edge, not center
            shooterX = Math.max(0, Math.min(shooterX, gameAreaWidth - shooterWidth));

            DOMElements.shooter.style.left = `${shooterX}px`;
            // Ensure transform is not interfering if using style.left
             // DOMElements.shooter.style.transform = 'translateX(0)';
        }


        function fireBullet() {
            // **** ADD PAUSE CHECK ****
             if (isPaused || !gameActive) return;

             // Bullet Limit Check
             if (!unlimitedBulletsEnabled) {
                 const shotsFired = questionAttempts[currentQuestion] || 0;
                 if (shotsFired >= bulletLimit) {
                     console.log(`Attempted to fire with no bullets left (Limit: ${bulletLimit}).`);
                     if (!questionFailed) { // Only show popup if question not already failed
                         showOutOfBulletsPopup();
                     }
                     return;
                 }
             }

             // Increment attempt count only if allowed and not paused
             // Ensure index exists in map first
             if (typeof questionAttempts[currentQuestion] === 'undefined') {
                 questionAttempts[currentQuestion] = 0;
             }
             questionAttempts[currentQuestion]++;


             // Update UI only if bullets are limited
             if (!unlimitedBulletsEnabled) {
                 updateBulletCounterUI();
             }

             // Get position data (relative to game area)
             const shooterRect = DOMElements.shooter.getBoundingClientRect();
             const gameAreaRect = DOMElements.gameArea.getBoundingClientRect();
             if (!shooterRect || !gameAreaRect) return; // Safety check

             // Create and position the bullet element
             const newBulletElement = DOMElements.bulletTemplate.cloneNode(true);
             newBulletElement.style.display = 'block';
             newBulletElement.removeAttribute('id');

             const computedStyle = getComputedStyle(DOMElements.bulletTemplate);
              // Use offsetWidth/Height first, fallback to computed style, then fallback to fixed values
             const bulletWidth = newBulletElement.offsetWidth || parseInt(computedStyle.width) || 8;
             const bulletHeight = newBulletElement.offsetHeight || parseInt(computedStyle.height) || 18;


             // Calculate start X based on shooter's visual center
             const shooterCenterX = shooterRect.left - gameAreaRect.left + shooterRect.width / 2;
             const startX = shooterCenterX - bulletWidth / 2;
             // Calculate start Y just above the shooter (consider barrel offset visually)
             const startY = shooterRect.top - gameAreaRect.top - bulletHeight - 5; // Adjust -5 as needed

             newBulletElement.style.left = `${startX}px`;
             newBulletElement.style.top = `${startY}px`;

             DOMElements.gameArea.appendChild(newBulletElement);

             // Track the new bullet's state
             activeBullets.push({
                 element: newBulletElement,
                 x: startX,
                 y: startY,
                 width: bulletWidth,
                 height: bulletHeight
             });
        }

        // --- NEW FUNCTION for Out of Bullets Popup ---
        function showOutOfBulletsPopup() {
            if (questionFailed || !gameActive || isPaused) return; // Don't show if already failed, inactive, or paused

            questionFailed = true; // Mark question as failed due to out of bullets
            // Don't call pauseTimer() - handled by isPaused flag now
            stopGameLoop(); // Stop movement

            // Record failure immediately
            userData.attempts.push({
                question: currentQuestion + 1,
                colA: quizData[currentQuestion].colA,
                correctAnswer: currentCorrectAnswer,
                time: Math.round((Date.now() - questionStartTime) / 1000),
                points: 0,
                attempts: bulletLimit, // Record the limit reached
                status: 'failed'
            });

            Swal.fire({
                title: 'Out of Bullets!',
                text: `You used all ${bulletLimit} bullet${bulletLimit === 1 ? '' : 's'} without hitting the correct target.`,
                icon: 'warning',
                showCancelButton: true,
                confirmButtonText: 'Next Question (0 points)',
                cancelButtonText: 'Try Again',
                confirmButtonColor: primaryColor,
                cancelButtonColor: textSecondary,
                allowOutsideClick: false,
                allowEscapeKey: false,
            }).then((result) => {
                 // Check if still failed (user might have navigated away)
                 if (!questionFailed) return;

                if (result.isConfirmed) {
                    console.log(`User chose Next Question after running out of bullets.`);
                    currentQuestion++;
                    loadQuestion(); // Load next question (will reset questionFailed)
                } else if (result.dismiss === Swal.DismissReason.cancel) {
                    console.log(`User chose Try Again after running out of bullets.`);

                    // Increment retry count
                    questionRetryCount[currentQuestion] = (questionRetryCount[currentQuestion] || 0) + 1;
                    console.log(`Incremented retry count for question ${currentQuestion + 1} to ${questionRetryCount[currentQuestion]}`);

                    questionAttempts[currentQuestion] = 0; // Reset bullet attempts for retry

                    // Remove the 'failed' entry we just added
                     const failedIndex = userData.attempts.findIndex(a => a.question === (currentQuestion + 1) && a.status === 'failed');
                     if(failedIndex > -1) {
                        // Ensure we remove the *last* one if somehow multiple exist (shouldn't happen here)
                        const lastFailedIndex = userData.attempts.map(a => a.question === (currentQuestion + 1) && a.status === 'failed').lastIndexOf(true);
                        if (lastFailedIndex > -1) {
                             userData.attempts.splice(lastFailedIndex, 1);
                             console.log("Removed preliminary failed attempt record for retry.");
                        }
                     } else {
                         console.warn("Could not find the preliminary failed attempt record to remove for retry.");
                     }

                    loadQuestion(); // Reload current question (will reset questionFailed)
                }
            });
        }

        // --- Game Loop ---
        function startGameLoop() {
            if (!gameLoopId) { // Prevent multiple loops starting
                gameLoopId = requestAnimationFrame(gameLoop);
            }
        }

        function stopGameLoop() {
            if (gameLoopId) {
                cancelAnimationFrame(gameLoopId);
                gameLoopId = null;
            }
            // gameActive = false; // Don't set gameActive false here, only on screen change/end
            keysPressed = {}; // Clear keys when loop stops
        }

        function gameLoop() {
            // **** MODIFY: Add Pause Check at the START ****
            if (isPaused) {
                gameLoopId = requestAnimationFrame(gameLoop); // Keep loop alive but idle
                return;
            }

            // --- Core Loop Condition Check ---
            if (!gameActive || questionFailed) {
                stopGameLoop(); // Stop loop if game ended or question failed
                return;
            }

            // --- Get Dimensions/Positions ---
            const gameAreaRect = DOMElements.gameArea?.getBoundingClientRect();
            const shooterRect = DOMElements.shooter?.getBoundingClientRect();
            if (!gameAreaRect || !shooterRect) { // Safety check
                 console.error("Game area or shooter bounds not available.");
                 stopGameLoop();
                 return;
            }


            // --- 1. Update Shooter Position ---
            updateShooterPosition();

            // --- 2. Update Bullets & Check Collisions / Offscreen ---
            for (let i = activeBullets.length - 1; i >= 0; i--) {
                let bullet = activeBullets[i];
                bullet.y -= BULLET_SPEED;
                if (bullet.element) bullet.element.style.top = `${bullet.y}px`;

                // Offscreen check
                if (bullet.y < -bullet.height) {
                    bullet.element?.remove();
                    activeBullets.splice(i, 1);
                    continue; // Go to next bullet
                }

                // Collision check
                const bulletRect = {
                    left: bullet.x, top: bullet.y,
                    right: bullet.x + bullet.width, bottom: bullet.y + bullet.height
                };

                for (let j = activeTargets.length - 1; j >= 0; j--) {
                    let target = activeTargets[j];
                    if (target.hit) continue; // Skip already hit targets

                    const targetRect = {
                         left: target.x, top: target.y,
                         right: target.x + target.width, bottom: target.y + target.height
                    };

                    // AABB collision detection
                    if (bulletRect.left < targetRect.right && bulletRect.right > targetRect.left &&
                        bulletRect.top < targetRect.bottom && bulletRect.bottom > targetRect.top)
                    {
                        bullet.element?.remove();
                        activeBullets.splice(i, 1); // Remove bullet
                        target.hit = true; // Mark target as hit
                        handleBulletHit(target); // Process the hit
                        // Break inner loop (j) since bullet is gone
                        break;
                    }
                }
            }

            // --- 3. Update Target Positions & Check Bounce / Failure ---
             let targetReachedBottom = false;
             const shooterTopRelative = shooterRect.top - gameAreaRect.top;

            activeTargets.forEach(target => {
                if (target.hit) return; // Skip hit targets

                target.x += target.vx;
                target.y += target.vy;

                // Bounce off side walls
                if (target.x <= 0 || (target.x + target.width) >= gameAreaRect.width) {
                    target.vx *= -1;
                    target.x = Math.max(0, Math.min(target.x, gameAreaRect.width - target.width)); // Clamp position
                }

                // Update element position
                if (target.element) {
                     target.element.style.left = `${target.x}px`;
                     target.element.style.top = `${target.y}px`;
                }


                 // Check for Failure (Target reaches near shooter)
                 if (!questionFailed && (target.y + target.height) >= (shooterTopRelative - TARGET_FAILURE_PADDING)) {
                    targetReachedBottom = true;
                 }
            });

            // --- 4. Handle Failure State (Target Reaching Bottom) ---
            if (targetReachedBottom) {
                 handleQuestionFailure("TargetReachedBottom");
                 // Loop will stop on the next iteration check because questionFailed is true
            }

            // --- 5. Request Next Frame ---
             // Only continue if game is still active AND not paused (implicitly handled by checks above)
             if (gameActive && !questionFailed && !isPaused) {
                gameLoopId = requestAnimationFrame(gameLoop);
             } else {
                 stopGameLoop(); // Ensure loop stops if conditions met
             }
        }

        function loadQuestion() {
            // **** START: Reset per-question pause duration ****
            totalPauseDurationForQuestion = 0;
            // **** END: Reset per-question pause duration ****

            // Stop previous loop before loading new question
            stopGameLoop();

            gameActive = true; // Ensure game is marked active
            questionFailed = false; // Reset failure flag for the new question

            if (currentQuestion >= quizData.length) {
                showResults(); // Finished all questions
                return;
            }

            clearGameElements(); // Clear old targets/bullets from the DOM and arrays

            const questionData = quizData[currentQuestion];
            if (!questionData) { // Safety check
                console.error(`Error: No data found for question index ${currentQuestion}.`);
                showResults(); // End game if data is corrupt/missing
                return;
            }
            currentCorrectAnswer = questionData.colB;

            DOMElements.shooter.textContent = questionData.colA;

            // Ensure shooter position is centered after text content update
            requestAnimationFrame(() => {
                positionShooter();
            });

            // Update UI elements
            const progress = ((currentQuestion + 1) / quizData.length) * 100;
            DOMElements.progressBar.style.width = `${progress}%`;
            DOMElements.questionNumberDisplay.textContent = `Question ${currentQuestion + 1} of ${quizData.length}`;
            updateBulletCounterUI(); // Update bullet count display

            spawnTargets(); // Create new targets for this question

            questionStartTime = Date.now(); // Reset timer reference for this question
            // Timer continues based on the global interval and isPaused state

            startGameLoop(); // Start the animation loop for the new question
        }


        function handleBulletHit(target) {
            // Prevent processing if paused or question already marked as failed
            if (isPaused || questionFailed) return;

            if (target.word === currentCorrectAnswer) {
                // --- CORRECT HIT ---
                target.element?.classList.add('target-hit-correct');

                // **** Calculate CORRECTED time taken, subtracting pause duration ****
                const timeTaken = Math.max(1, Math.round((Date.now() - questionStartTime - totalPauseDurationForQuestion) / 1000));
                // **** END Correction ****

                const retries = questionRetryCount[currentQuestion] || 0;
                const timeBasedPoints = calculatePoints(timeTaken, retries); // Uses corrected time

                const shotsFired = questionAttempts[currentQuestion] || 1;
                let bonusPoints = 0;
                if (shotsFired === 1) bonusPoints = 10;
                else if (shotsFired === 2) bonusPoints = 5;
                else if (shotsFired === 3) bonusPoints = 1;

                const totalPointsThisRound = timeBasedPoints + bonusPoints;
                userData.totalPoints += totalPointsThisRound;

                userData.attempts.push({
                    question: currentQuestion + 1,
                    colA: quizData[currentQuestion].colA,
                    correctAnswer: currentCorrectAnswer,
                    time: timeTaken, // **** Record the corrected time ****
                    points: totalPointsThisRound,
                    attempts: shotsFired,
                    status: 'correct'
                });

                let popupText = `+${timeBasedPoints} (time)`;
                if (bonusPoints > 0) popupText += ` +${bonusPoints} (bonus)`;
                popupText += ` = ${totalPointsThisRound} total!`;

                // Show non-blocking toast
                Swal.fire({
                    title: 'Correct!', text: popupText, icon: 'success',
                    toast: true, position: 'top-end',
                    showConfirmButton: false, timer: POPUP_TIMER_CORRECT_MS, timerProgressBar: true,
                    didOpen: (toast) => {
                        toast.addEventListener('mouseenter', Swal.stopTimer);
                        toast.addEventListener('mouseleave', Swal.resumeTimer);
                        const currentFocus = document.activeElement;
                        setTimeout(() => {
                            (currentFocus && currentFocus !== document.body) ? currentFocus.focus() : DOMElements.gameArea?.focus();
                        }, 0);
                    }
                });

                // --- IMMEDIATE NEXT QUESTION ---
                currentQuestion++;
                requestAnimationFrame(() => {
                    loadQuestion();
                });

            } else {
                // --- INCORRECT HIT ---
                target.element?.classList.add('target-hit-incorrect');

                Swal.fire({
                    title: 'Incorrect!', icon: 'error',
                    toast: true, position: 'top-end',
                    showConfirmButton: false, timer: POPUP_TIMER_INCORRECT_MS, timerProgressBar: true,
                    didOpen: (toast) => {
                        toast.addEventListener('mouseenter', Swal.stopTimer);
                        toast.addEventListener('mouseleave', Swal.resumeTimer);
                        const currentFocus = document.activeElement;
                        setTimeout(() => {
                            (currentFocus && currentFocus !== document.body) ? currentFocus.focus() : DOMElements.gameArea?.focus();
                        }, 0);
                    }
                });

                const incorrectAnimationDuration = 500; // ms
                setTimeout(() => {
                    target.element?.remove();
                    activeTargets = activeTargets.filter(t => t !== target);
                }, incorrectAnimationDuration);
            }
        }


        function handleQuestionFailure(reason = "TargetReachedBottom") {
            // Prevent multiple failure triggers for the same question instance
            if (questionFailed || isPaused || !gameActive) {
                console.log("handleQuestionFailure skipped. State:", { questionFailed, isPaused, gameActive });
                return;
            }
            questionFailed = true; // Set flag immediately
            console.log(`Handling Question Failure. Reason: ${reason}`);

            // Don't pause timer explicitly, isPaused handles timing
            stopGameLoop(); // Stop movement

            // Record failure only if not already recorded for this question
            const alreadyRecorded = userData.attempts.some(a => a.question === (currentQuestion + 1) && a.status === 'failed');
            if (!alreadyRecorded) {
                // **** Calculate CORRECTED time taken, subtracting pause duration ****
                const timeTaken = Math.round((Date.now() - questionStartTime - totalPauseDurationForQuestion) / 1000);
                // **** END Correction ****

                userData.attempts.push({
                    question: currentQuestion + 1,
                    colA: quizData[currentQuestion].colA,
                    correctAnswer: currentCorrectAnswer,
                    time: timeTaken, // **** Record the corrected time ****
                    points: 0,
                    attempts: questionAttempts[currentQuestion] || 0, // Record attempts made
                    status: 'failed'
                });
                console.log("Recorded 'failed' status for question:", currentQuestion + 1);
            } else {
                console.log("Failure already recorded for question:", currentQuestion + 1);
            }

            // Show appropriate failure popup
            let failureTitle = reason === "TargetReachedBottom" ? 'Target Reached Bottom!' : 'Question Failed!';
            let failureText = reason === "TargetReachedBottom" ? "You didn't hit the correct target in time." : "You failed the question.";

            Swal.fire({
                title: failureTitle, text: failureText, icon: 'warning',
                showCancelButton: true,
                confirmButtonText: 'Next Question (0 points)',
                cancelButtonText: 'Try Again',
                confirmButtonColor: primaryColor, cancelButtonColor: textSecondary,
                allowOutsideClick: false, allowEscapeKey: false,
            }).then((result) => {
                if (!gameActive) return;

                if (result.isConfirmed) {
                    console.log("User chose Next Question after failure.");
                    currentQuestion++;
                    loadQuestion(); // Load next question
                } else if (result.dismiss === Swal.DismissReason.cancel) {
                    console.log("User chose Try Again after failure.");

                    questionRetryCount[currentQuestion] = (questionRetryCount[currentQuestion] || 0) + 1;
                    console.log(`Incremented retry count for question ${currentQuestion + 1} to ${questionRetryCount[currentQuestion]}`);
                    questionAttempts[currentQuestion] = 0;

                    const lastFailedIndex = userData.attempts.map(a => a.question === (currentQuestion + 1) && a.status === 'failed').lastIndexOf(true);
                    if (lastFailedIndex > -1) {
                        userData.attempts.splice(lastFailedIndex, 1);
                        console.log("Removed preliminary failed attempt record for retry.");
                    } else {
                        console.warn("Could not find the preliminary failed attempt record to remove for retry.");
                    }

                    loadQuestion(); // Reload the *current* question
                }
            });
        }

     

      
        // --- Timer Functions ---
        function startTimer() {
            clearInterval(timerInterval);
            elapsedTime = 0;
            if (DOMElements.timerDisplay) DOMElements.timerDisplay.textContent = elapsedTime;
            // isPaused should be false here, set in startQuiz
            userData.startTime = Date.now(); // Record the absolute start time
            let lastTickTime = userData.startTime; // Track time of the last interval execution for pause adjustment

            timerInterval = setInterval(() => {
                // **** MODIFY: Use isPaused flag ****
                if (!isPaused && gameActive) { // Only advance timer if game active and not paused
                    const now = Date.now();
                    // Calculate elapsed time based on the difference from the potentially adjusted startTime
                    elapsedTime = Math.floor((now - userData.startTime) / 1000);
                    if (DOMElements.timerDisplay) DOMElements.timerDisplay.textContent = elapsedTime;
                    lastTickTime = now; // Update last tick time
                } else if (isPaused && gameActive) {
                     // If paused, adjust the *absolute* startTime forward
                     // by the duration of the pause since the last tick.
                     const pauseDuration = Date.now() - lastTickTime;
                     userData.startTime += pauseDuration;
                     lastTickTime = Date.now(); // Reset lastTickTime to now to prevent drift on resume
                     // Don't update the displayed time while paused
                }
            }, 1000); // Check every second
        }

         // REMOVED pauseTimer() and resumeTimer() as they are now redundant

        // --- Scoring ---
        function calculatePoints(seconds, retryCount = 0) {
             const brackets = [[5,10],[10,9],[15,8],[20,7],[25,6],[30,5],[40,4],[50,3],[60,2],[Infinity,1]];
             let basePoints = 1; // Default to 1 point if time exceeds all brackets

             for (const [max, points] of brackets) {
                 if (seconds <= max) {
                     basePoints = points;
                     break;
                 }
             }
             // Apply reduction for retries, minimum 0 points
             const finalPoints = Math.max(0, basePoints - retryCount);
             return finalPoints;
        }

        // --- Utility ---
        function shuffle(array) {
            // Fisher-Yates shuffle
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- Results Display ---
        function showResults() {
            stopGameLoop();
            clearInterval(timerInterval);

             // **** START: Reset pause state on showing results ****
             if (isPaused) {
                 isPaused = false; // Reset state flag
             }
             // Hide pause button and overlay explicitly
             if (DOMElements.pauseResumeButton) DOMElements.pauseResumeButton.style.display = 'none';
             if (DOMElements.pauseOverlay) DOMElements.pauseOverlay.style.display = 'none';
             // **** END: Reset pause state on showing results ****


             // Detach quiz screen carefully
             if (DOMElements.quizScreen && DOMElements.quizScreen.parentNode) {
                try {
                    detachedQuizScreen = DOMElements.quizScreen.parentNode.removeChild(DOMElements.quizScreen);
                    console.log("Detached quiz screen for results.");
                } catch (e) {
                    console.error("Error detaching quiz screen:", e);
                     // If error, try hiding it as fallback
                     DOMElements.quizScreen.style.display = 'none';
                     DOMElements.quizScreen.classList.remove('active');
                     detachedQuizScreen = null; // Don't keep reference if removal failed
                }
             } else {
                 console.warn("Quiz screen not found or already detached when showing results.");
                 detachedQuizScreen = null; // Ensure reference is null
             }


            showScreen('resultsScreen'); // Show results screen

            // Calculate stats
             const completionDate = new Date();
             const day = completionDate.getDate().toString().padStart(2, '0');
             const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
             const month = monthNames[completionDate.getMonth()];
             const year = completionDate.getFullYear();
             const hours = completionDate.getHours().toString().padStart(2, '0');
             const minutes = completionDate.getMinutes().toString().padStart(2, '0');
             const completionTimestamp = `${day} ${month} ${year}, ${hours}:${minutes}`;

             const correctCount = userData.attempts.filter(a => a.status === 'correct').length;
             const failedCount = userData.attempts.filter(a => a.status === 'failed').length;
             const attemptedCount = correctCount + failedCount;
             const skippedCount = Math.max(0, quizData.length - attemptedCount);

            // Update Summary - Check elements exist
             if (DOMElements.resultSummary) {
                DOMElements.resultSummary.innerHTML = `
                    <div class="result-stat"><i class="fas fa-user"></i><span><strong>Name:</strong> ${userData.name || 'N/A'}</span></div>
                    <div class="result-stat"><i class="fas fa-calendar-check"></i><span><strong>Completed:</strong> ${completionTimestamp}</span></div>
                    <div class="result-stat"><i class="fas fa-book"></i><span><strong>Quiz Title:</strong> ${window.quizTitle || 'N/A'}</span></div>
                    <div class="result-stat"><i class="fas fa-trophy"></i><span><strong>Total Score:</strong> ${userData.totalPoints} points</span></div>
                    <div class="result-stat"><i class="fas fa-check-circle" style="color: var(--success);"></i><span><strong>Correct:</strong> ${correctCount} / ${quizData.length}</span></div>
                    <div class="result-stat"><i class="fas fa-times-circle" style="color: var(--danger);"></i><span><strong>Failed/Skipped:</strong> ${failedCount + skippedCount} / ${quizData.length}</span></div>
                `;
             }

            // Update Table - Check element exists
             if (DOMElements.resultsTable) {
                let tableHTML = `
                    <thead>
                        <tr>
                            <th>#</th>
                            <th>Word</th>
                            <th>Correct Match</th>
                            <th>Status</th>
                            <th>Time (s)</th>
                            <th>Attempts</th>
                            <th>Retries</th>
                            <th>Points</th>
                        </tr>
                    </thead>
                    <tbody>`;

                for (let i = 0; i < quizData.length; i++) {
                    const questionNum = i + 1;
                    const attemptData = userData.attempts.find(a => a.question === questionNum);
                    const questionInfo = quizData[i];
                    const retryCount = questionRetryCount[i] || 0;

                    if (attemptData) {
                        let statusClass = attemptData.status === 'correct' ? 'correct' : 'failed';
                        let statusText = attemptData.status === 'correct' ? 'Correct' : (attemptData.status === 'failed' ? 'Failed' : 'Unknown');
                         // Ensure points and time are numbers or '-'
                         const displayTime = typeof attemptData.time === 'number' ? attemptData.time : '-';
                         const displayAttempts = typeof attemptData.attempts === 'number' ? attemptData.attempts : '-';
                         const displayPoints = typeof attemptData.points === 'number' ? attemptData.points : '0'; // Default points to 0 if unknown
                        tableHTML += `
                            <tr>
                                <td>${questionNum}</td>
                                <td>${questionInfo?.colA || 'N/A'}</td>
                                <td>${questionInfo?.colB || 'N/A'}</td>
                                <td class="${statusClass}">${statusText}</td>
                                <td>${displayTime}</td>
                                <td>${displayAttempts}</td>
                                <td>${retryCount}</td>
                                <td>${displayPoints}</td>
                            </tr>`;
                    } else { // Skipped
                        tableHTML += `
                            <tr>
                                <td>${questionNum}</td>
                                <td>${questionInfo?.colA || 'N/A'}</td>
                                <td>${questionInfo?.colB || 'N/A'}</td>
                                <td class="incorrect"><em>Skipped</em></td>
                                <td>-</td>
                                <td>0</td>
                                <td>${retryCount}</td>
                                <td>0</td>
                            </tr>`;
                    }
                }
                tableHTML += `</tbody>`;
                DOMElements.resultsTable.innerHTML = tableHTML;
            }
        }


        function togglePause() {
            if (!gameActive) return; // Don't allow pause if game isn't active

            isPaused = !isPaused; // Toggle the flag
            console.log("Game paused:", isPaused);

            const button = DOMElements.pauseResumeButton;
            const icon = button?.querySelector('i');
            const overlay = DOMElements.pauseOverlay;

            if (isPaused) {
                // --- PAUSE ACTIONS ---
                pauseStartTime = Date.now(); // Record when pause starts
                keysPressed = {}; // Clear keys

                if (icon) { /* ... icon change ... */ }
                if (button) button.title = 'Resume Game';
                if (overlay) overlay.style.display = 'flex';
                if (Swal.getTimerLeft()) Swal.stopTimer(); // Stop Swal timer

            } else {
                // --- RESUME ACTIONS ---
                if (pauseStartTime > 0) { // Make sure pause was actually started
                    const pauseDuration = Date.now() - pauseStartTime;
                    totalPauseDurationForQuestion += pauseDuration; // Add to question's total pause time
                    // Adjust the main timer's absolute start time (handled in setInterval now, this part is technically redundant if interval logic is correct, but safe)
                    // userData.startTime += pauseDuration;
                    pauseStartTime = 0; // Reset pause start time
                }

                if (icon) { /* ... icon change ... */ }
                if (button) button.title = 'Pause Game';
                if (overlay) overlay.style.display = 'none';
                // Optional: Resume Swal timer (keep commented unless needed)
                // if (Swal.isVisible() && !Swal.getTimerLeft()) { Swal.resumeTimer(); }

                startGameLoop(); // Ensure loop continues
            }
        }


        // --- Results Actions ---
        function screenshotResults() {
            // Ensure results screen card exists
            const resultsElement = DOMElements.resultsScreen?.querySelector('.card');
             if (!resultsElement) {
                 Swal.fire('Error', 'Could not find results card to screenshot.', 'error', { confirmButtonColor: primaryColor });
                 return;
             }

            Swal.fire({ title: 'Generating Screenshot', text: 'Please wait...', allowOutsideClick: false, showConfirmButton: false, willOpen: () => Swal.showLoading() });

            html2canvas(resultsElement, {
                 scale: 2, // Higher resolution
                 useCORS: true, // For potential external resources if any were used (unlikely here)
                 logging: false // Reduce console noise
                 }).then(canvas => {
                Swal.close();
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                 const safeName = (userData.name || 'User').replace(/[^a-z0-9]/gi, '_'); // Sanitize name for filename
                 link.download = `LanguageMarksman-Results-${safeName}-${timestamp}.png`;
                link.href = canvas.toDataURL("image/png");
                link.click(); // Trigger download
                link.remove(); // Clean up the link element
                Swal.fire('Success!', 'Results screenshot downloaded.', 'success', { confirmButtonColor: primaryColor });
            }).catch(err => {
                Swal.close();
                console.error("Screenshot error:", err);
                Swal.fire('Error', 'Could not generate screenshot. See console for details.', 'error', { confirmButtonColor: primaryColor });
            });
        }

        function reviewQuestions() {
            // Crucial: Ensure we have the sheet ID to restart the correct quiz
            if (!currentSheetId) {
                console.error("Play Again clicked, but currentSheetId is missing. Cannot restart.");
                Swal.fire({
                    title: "Error",
                    text: "Could not determine which game to play again. Returning home.",
                    icon: "error",
                    confirmButtonColor: primaryColor
                });
                goHome(); // Fallback to home screen
                return;
            }

            console.log(`Restarting quiz with ID: ${currentSheetId}`);

            // Call startQuizFlow which handles resetting, loading, and showing the name screen.
            // The pause state will be correctly initialized when startQuiz is called later in the flow.
            startQuizFlow(currentSheetId);
        }

    </script>

</body>
</html>
